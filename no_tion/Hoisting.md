# 호이스팅
**변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것**

변수나 함수가 어디서 선언이 되든지간에 최상단에 위치하게 되어 동일 스코프에서는 어디서든 참조할 수 있다는 것.

```js
addString("가나다", "라마바사");

function addString(str1, str2)
{
    return str1 + str2; // "가나다라마바사"
}
```

`addString()` 실행 시점에 함수가 선언되지 않았지만 정상적으로 동작.

선언을 상단으로 올려진 것 같은 현상을 통해 참조할 수 있도록 하는 것이 **호이스팅**

위의 함수 선언은 동시에 초기화가 이루어져서 실행도 가능.

아래 함수표현식 스타일

```js
addString("123123", "456456");

var addString = function (str1, str2) {
    return str1 + str2;
}
```

IE11에서는 오류 발생하지만 크롬 일부 버전에서는 정상 작동.

함수표현식 스타일이 호이스팅이 일어나지 않는 것은 아닌듯.

브라우저와 javascript 엔진 버전상의 처리 방식이 다르므로, 사용시 유의.

함수표현식을 let, const로 선언해도 오류 발생.


### **_짚고 가야 할 것_**
- 호이스팅은 코드를 실행하기 전 변수선언/함수선언을 해당 스코프의 최상단으로 끌어올리는 것이 아님.
- 호이스팅은 코드가 실행하기 전 변수선언/함수선언이 해당 스코프의 최상단으로 끌어 올려진 것 같은 현상.

즉, 호이스팅 = 선언이 코드 실행보다 먼저 메모리에 저장되는 과정으로 인한 현상

## 변수 호이스팅

자바스크립트의 모든 선언에선 호이스팅이 발생.

그런데 `let`, `const`, `class`을 이용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작이 됨.

`let` 키워드로 선언된 변수를 선언문 이전에 참조하면 참조 에러(ReferenceError) 발생

`let` 키워드로 선언된 변수는 스코프의 시작에서 변수의 선언까지 **일시적 사각지대(Temporal Dead Zone; TDZ)** 에 빠지기 때문

이 때 참조에러가 나지만 호이스팅이 동작하지 않은 것은 아님. 선언은 끌어올려졌음. (정확히는 선언이 코드 실행 전에 메모리에 저장)

오류가 나는 이유 : `var` 키워드는 선언이 되면 `undefined`로 초기화되어 메모리에 저장되는데 `let`과 `const`는 초기화되지 않은 상태로 선언만 메모리에 저장되기 때문

초기화 되지 않으면 변수를 참조할 수 없음. 그래서 참조에러가 발생.

즉, `let`, `const`도 호이스팅이 발생했으나, 초기화가 되지 않아서 참조에러가 발생하는 것.

```js
let foo = 1;
{
    console.log(foo);
    let foo = 2;
}
```

이것두 호이스팅 때문에 블록 스코프 내에서 오류 발생함.

`var` 키워드만 호이스팅이 발생하는 것이 아님!

## 변수의 생성 단계와 호이스팅이 발생하는 흐름

### 1단계: 선언 단계(Declaration phase)
- 변수를 실행 컨텍스트의 변수 객체에 등록.
- 이 변수 객체는 스코프가 참조하는 대상이 됨.

### 2단계: 초기화 단계(Initialization phase)
- 변수 객체에 등록된 변수를 위한 공간을 메모리에 확보.
- 이 단계에서 변수는 undefined로 초기화.

### 3단계: 할당 단계(Assignment phase)
- undefined로 초기화된 변수에 실제 값을 할당.

위에서 말했듯,
###`var` 키워드로 선언한 변수는 선언 단계와 초기화 단계가 한번에 이루어짐.

_스코프에 변수를 등록(선언 단계)하고 메모리에 변수를 위한 공간을 확보한 후, undefined로 초기화(초기화 단계)_

변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는 이유임. (하지만 undefined 반환)

이후에 변수 할당문에 도달하면 그 때 값이 할당 되는 것.

### `let` 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행

_스코프에 변수를 등록(선언 단계)하지만 초기화 단계는 변수 선언문에 도달했을 때(코드 실행 후) 이뤄짐_

초기화 이전(변수의 메모리 공간이 확보되지 않았을 때)에 변수에 접근하려고 하면 참조 에러가 발생.

따라서 스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없음. 

스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 **일시적 사각지대(Temporal Dead Zone; TDZ)** 

### 호이스팅 예시

#### 변수 선언
```js
// 호이스팅 때문에 선언이 끌어올려져서 오류 안 남.
console.log(text); // (선언 + 초기화된 상태)
text = 'Hanamon!'; // (선언 + 초기화 + 할당된 상태)
var text;
console.log(text);
```
```js
// 호이스팅 때문에 선언이 끌어올려졌지만 초기화 안 된 상태에서 참조해서 오류 남.
console.log(text); 
// (선언된 상태, 초기화 (메모리 공간 확보와 undefined로 초기화) 안되서 참조 불가능 -> 에러남)
let text; // 여기서 초기화 단계가 실행됨
```
```js
const text; // 에러남. 애초에 const 키워드로 재할당 불가능! 그래서 선언과 동시에 할당해야 함
```

#### 함수 선언
```js
foo1(); // 함수 선언문에서는 호이스팅 일어난다.
foo2(); // 함수 표현식이라서 호이스팅 안된다.
function foo1() {
  console.log('Hello');
}
var foo2 = function() {
  console.log('world');
}
```

함수 표현식이 호이스팅 안 되는 이유 :
- 함수 표현식은 변수에 함수가 할당되는 것. 
- 함수 표현식은 변수 호이스팅으로 동작. 
- 변수 선언문은 런타임 이전에 생성이 되고 변수는 undefined으로 초기화. 
- 변수에 할당되는 함수는 런타임에 평가되므로 함수 표현식 이전에 참조나 호출이 불가능.

함수 선언문은 ?
- 함수 선언문으로 정의한 함수는 런타임 이전에 함수 객체가 먼저 생성. 
- 런타임에는 이미 함수 객체가 생성되어 있으므로 함수 선언문 이전에 함수를 참조하고 호출
