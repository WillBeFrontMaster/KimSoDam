2022 / 06 / 20
Study
---------------
# **클로저(Closure)**

## **정의**
### **함수와 함수가 선언된 어휘적(lexical) 환경의 조합**
-   클로저는 함수를 지칭하고 또 그 함수가 선언된 환경과의 관계라는 개념이 합쳐짐.
### **클로저의 핵심** 👉 스코프를 이용하여 변수의 접근 범위를 닫는 것. (폐쇄성)
- 외부함수 스코프 👉  내부함수 스코프로 접근 불가능
- 내부 함수 👉 외부 함수에 선언된 변수 접근 가능
### **함수 호출 환경과 별개로, 기존 선언 환경(어휘적 환경)을 기준으로 변수 조회**
- 외부함수 실행이 종료된 후에도 클로저 함수는 외부 함수의 스코프(함수가 선언된 어휘적 환경) 접근 가능
- 회부 함수 스코프가 내부 함수에 의해 언제든 참조 가능
- 클로저 남발할 경우 퍼포먼스 저하
### **상위 스코프의 식별자를 포함하여 쓰여있는 내부 함수 코드 자체를 어휘적 환경(lexical environment)라고 부를 수 있음**

```js
function outerFunc() {
	var x = 10;
	var innerFunc = function() { console.log(x)l };
	innerFunc();
}

outerFunc(); // 10
```
함수 `outerFunc` 내에서 내부함수 `innerFunc`가 선언되고 호출
이 때, 내부함수 `innerFunc`는 자신을 포함하고 있는 외부함수 `outerFunc`의 변수 `x`에 접근할 수 있음.
함수 `innerFunc`가 함수 `outerFunc`의 외부에 선언되었기 때문

---
스코프는 함수를 호출할 때가 아니라 함수를 어디에 선언하였는지에 따라 결정. 
이를 **렉시컬 스코핑(Lexical scoping)** 이라 함.
위 예제의 함수 `innerFunc`는 함수 `outerFunc`의 내부에서 선언되었기 때문에 함수 `innerFunc`의 상위 스코프는 함수 `outerFunc`. 함수 `innerFunc`가 전역에 선언되었다면 함수 `innerFunc`의 상위 스코프는 전역 스코프가 된다.

---

## **클로저 함수의 장점**

### **1. 데이터를 보존할 수 있다.**

클로저 함수는 외부 함수의 실행이 끝나더라도 외부 함수 내 변수를 사용할 수 있음.
특정 데이터를 스코프 안에 가두어 둔 채로 사용할 수 있게 하는 폐쇄성 가짐.

### **2. 정보의 접근 제한 (캡슐화)**

**클로저 모듈 패턴**을 사용하여 객체에 담아 여러 개의 함수를 리턴하도록 만들 수 있음.
이렇게 정보의 접근을 제한하는 것을 **캡슐화**라고 함.
### **3. 모듈화**
클로저 함수를 각각의 변수에 할당하면 각자 독립적으로 값을 사용하고 보존이 가능.
함수의 재사용성을 극대화하고 함수 하나를 독립적인 부품의 형태로 분리하는 것을 **모듈화**라고 함.
클로저를 이용하면 데이터와 메소드를 묶어다닐 수 있어 모듈화에 유리함.


## **클로저 활용**
- 상태유지
	```html
	<!DOCTYPE html>  
	<html>  
	<body>  
		<button class="toggle">toggle</button>  
		<div class="box" style="width: 100px; height: 100px; background: red;"></div>  
		
		<script>  
			var box = document.querySelector('.box');
			var toggleBtn = document.querySelector('.toggle'); 
			var toggle = (function () {
				var  isShow  =  false;
				
				// ① 클로저를 반환 
				return function () {  
					box.style.display = isShow ? 'block' : 'none';  
					// ③ 상태 변경  
					isShow = !isShow; 
				}; 
			})();  
			
			// ② 이벤트 프로퍼티에 클로저를 할당 
			toggleBtn.onclick = toggle;  
		</script>  
	</body>  
	</html>
	```

	① 즉시실행함수는 함수를 반환하고 즉시 소멸. 
		즉시실행함수가 반환한 함수는 자신이 생성됐을 때의 
		렉시컬 환경(Lexical environment)에 속한 변수 `isShow`를 기억하는 클로저. 
		클로저가 기억하는 변수 `isShow`는 `box` 요소의 표시 상태를 나타냄

	② 클로저를 이벤트 핸들러로서 이벤트 프로퍼티에 할당. 
		이벤트 프로퍼티에서 이벤트 핸들러인 클로저를 제거하지 않는 한 
		클로저가 기억하는 렉시컬 환경의 변수 `isShow`는 소멸하지 않음. 
		다시 말해 **현재 상태를 기억**

	③ 버튼을 클릭하면 이벤트 프로퍼티에 할당한 이벤트 핸들러인 클로저가 호출. 
		이때 `.box` 요소의 표시 상태를 나타내는 변수 `isShow`의 값이 변경. 
		변수 `isShow`는 클로저에 의해 참조되고 있기 때문에 유효하며 자신의 변경된 최신 상태를 게속해서 유지.

이처럼 클로저는 현재 상태(위 예제의 경우 `.box` 요소의 표시 상태를 나타내는 `isShow` 변수)를 기억하고 
이 **상태가 변경되어도 최신 상태를 유지해야 하는 상황에 매우 유용.** 

만약 **클로저가 없다면 상태를 유지하기 위해 전역 변수를 사용할 수 밖에 없음.**
전역 변수는 언제든지 **누구나 접근**할 수 있고 **변경**할 수 있기 때문에 많은 **부작용을 유발**해 
**오류의 원인이 되므로 사용을 억제.**


2022 / 06 / 23
Study
---------------
